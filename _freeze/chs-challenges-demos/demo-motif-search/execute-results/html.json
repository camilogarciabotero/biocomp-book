{
  "hash": "6d398b90e28017c463cceae0868d19d0",
  "result": {
    "markdown": "---\nexecute: \n  engine: knitr\n  freeze: auto\nfilters:\n  - code-filename\n  - nutshell\n  - lightbox\n---\n\n# Unix challenges {.unnumbered}\n\n## Motif search\n\nThe first thing we must do to solve the [Challenge](../chs-command-line/welcome-to-command-line.qmd#anatomy-of-a-command) is download the sequence of interest. In [Ch 1](../chs-command-line/welcome-to-command-line.qmd#anatomy-of-a-command) the genome of *Bacillus tequilensis* EA-CB0015 is proposed. There are several ways to do so. A simple way is to search in the NCBI databases for the entire genome and download as `FASTA` file (we cover the properties of this file format in [Ch 5](../chs-sequence-analysis/introduction-to-sequence-analysis.qmd)).\n\nWhen inspecting the file we see the following lines at the top\n\n``` bash\n>NZ_CP048852.1 Bacillus tequilensis strain EA-CB0015 chromosome, complete genome\nATGGAAAATATATTAGACCTGTGGAATCAAGCCCTTGCTCAAATCGAAAAAAAGTTGAGCAAACCGAGTTTTGAGACTTG\nGATGAAATCCACCAAAGCCCACTCACTGCAGGGAGATACACTGACGATCACGGCTCCCAATGAATTTGCCAGAGACTGGC\nTGGAGTCCAGATACTTGCATCTGATTGCAGATACTATATATGAATTAACCGGGGAAGAATTGAGCATTAAGTTTGTCATT\nCCTCAAAATCAAGATGTTGAGGACTTTATGCCAAAGCCGCAAGTCAAAAAAGCGGTTAAAGAAGATACATCTGATTTTCC\n```\n\nThe file is about 4 Mb and it is heavy to be opened in any editor. Therefore when looking for a pattern it becomes more useful the CLI.\n\nA first attempt to do is simply by using `grep` for the pattern presented on [Fig. @fig-motif]. So a first problem you will find is to represent multiple characters in one position of the pattern. There is a fantastic tool to so and its called *regular expressions* (regex). a regex is a way to encode groups of characters using single characters. For instance the character `*` (wildcards) represents any character, so it groups all characters and it is used broadly on the CLI. There are many regex dialects however and for `grep` the dot `.` represents any character and when the pipe `|` represents an special operator in the CLI, for grep regex it represents and `OR` operator.\n\nSo, the second step is to create our regular expression. Note the there are six characters in the expression that can adopt different characters. So our first regex is `TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT`. In the expression the parenthesis allow groups of characters.\n\nNow lets see if we can search for that pattern using `grep` and the appropriate option for using regex, which in this case is `-E`. Another simply way to use the `grep -E` combination is to use simple `egrep` command plus the `-c` option to count the number of *lines* where the pattern appears.\n\n\n::: {.cell hash='demo-motif-search_cache/html/unnamed-chunk-1_3301430eaaccfc873b42f696d6d47035'}\n\n```{.bash .cell-code}\negrep -c \"TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT\" data/Bteq-genome.fasta\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n43\n```\n:::\n:::\n\n\nIs this the solution? One might think it is solved. However, there are several issues to be aware. First `egrep -c` is counting the lines, what if in one line there are multiple matches? Then, the approach will showing a value under the actual number of motifs. So a way to solve that is to capture and extract the matches and print them out. A way to do that is to use the option `-o` which actually prints only the matching part of the lines, and then count them.\n\n\n::: {.cell hash='demo-motif-search_cache/html/unnamed-chunk-2_28f538c0d69bc50b553ede9a70e34a0e'}\n\n```{.bash .cell-code}\negrep -oc \"TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT\" data/Bteq-genome.fasta\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n43\n```\n:::\n:::\n\n\nThe outcome is the same tough. So is it solved? Every NCBI genome that is downloaded display a distinct character besides de nucleotide sequence. Every several number of nucleotides there is a new line `\\n` that enables the wrapping file into multiple lines. Therefore some motifs could be shopped by the `\\n` character so they will never appear with the regex used. A way to circumvent this issue is deleting the `\\n` in the entire file. We can easily do that with the translate `tr` command:\n\n\n::: {.cell hash='demo-motif-search_cache/html/unnamed-chunk-3_f3932454561c1534ab5516f65b4c36f0'}\n\n```{.bash .cell-code}\ntr -d '\\n' < data/Bteq-genome.fasta\n```\n:::\n\n\n``` bash\n>NZ_CP048852.1 Bacillus tequilensis strain EA-CB0015 chromosome, complete genomeATGGAAAATATATTAGACCTGTGGAATCAAGCCCTTGCTCAAATCGAAAAAAAGTTGAGCAAACCGAGTTTTGAGACTTGGATGAAATCCACCAAAGCCCACTCACTGCAGGGAGATACACTGACGATCACGGCTCCCAATGAATTTGCCAGAGACTGGCTGGAGTCCAGATACTTGCATCTGATTGCAGATACTATATATGAATTAACCGGGGAAGAATTGAGCATTAAGTTTGTCATTCCTCAAAATCAAGATGTTGAGGACTTTATGCCAAAGCCGCAAGTCAAAAAAGCGGTTAAAGAAGATACATCTGATTTTCC...\n```\n\nThe genome now lies in an entire and unique line along with its title. A way to chain the commands without creating intermediate files is by using the pipe `|` character. At the end we will use `wc -l` to count the occurrence (although `grep` has its own count option `\\c` it is inconvenient because it will count the lines and now the lines of the exact matches provided by the `-o` option and as we have just one line, then only will count to 1).\n\n\n::: {.cell hash='demo-motif-search_cache/html/unnamed-chunk-4_4c4f3e438bf10f454bdb88b48e97a104'}\n\n```{.bash .cell-code}\ntr -d '\\n' < data/Bteq-genome.fasta |\n    egrep -o \"TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT\" |\n    wc -l\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n      50\n```\n:::\n:::\n\n\nAre there yet? Well it turns out that the genome file contains only the 5'-3' strand of the genome. What about the other strands patterns? To search them we need to generate the reverse-complement (RC) of the motif so we are sure that they will appear when looking the 5'-3' strand. The RC regex will be `ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA\"` and adding this regex to the search willl be:\n\n\n::: {.cell hash='demo-motif-search_cache/html/unnamed-chunk-5_5019f682a6b1833c24afbd1cc5723be0'}\n\n```{.bash .cell-code}\ntr -d '\\n' < data/Bteq-genome.fasta |\n    egrep -o \"TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT|ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA\" |\n    wc -l\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n      94\n```\n:::\n:::\n\n\n## Motif search in multiple files\n\n```{.bash filename=\"motif-search.sh\"}\n#! /usr/bin/env bash\n\nmotif=\"TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT|ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA\"\n\nfor f in $(ls $1); do\n  if [ -s ${1}/${f} ]; then\n      motifnumber=$(tr -d '\\n' < ${1}/${f} | egrep -o $motif | wc -l)\n      header=$(head -n 1 ${1}/${f})\n      echo -e \"There are $motifnumber motifs in $header\"\n  else\n      echo \"$f is empty\"\n  fi\ndone\n```\nTo execute the command make sure to pass a folder with the decompressed genomes as the first argument.\n\n## Fragments digestion\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
---
execute: 
  engine: knitr
  freeze: auto
---

# Motif search

::: callout-warning
# [Challenge](../chs-command-line/welcome-to-command-line.qmd#anatomy-of-a-command)

Bacterial defense mechanisms to avoid bacteriophage infections are abundant. One of these is the restriction-modification system (RM-System), which works by targeting a specific site called *motif*, shared by the phage and bacteria, with methylations. Motifs are commonly represented as a *motif logo* which is a probabilistic representation of the nucleotides in a given position. Find the number of times the motif from [Fig. @fig-motif] appears on *B. tequilensis* EA-CB0015 genome using a command. Assume that probabilities are equal when multiple bases appeared at one site.

![A RM-system motif logo](../chs-command-line/imgs-cli/motif.png){#fig-motif}
:::

The first thing we must do is download the sequence of interest. In [Ch 1](../chs-command-line/welcome-to-command-line.qmd#anatomy-of-a-command) the genome of *Bacillus tequilensis* EA-CB0015 is proposed. There are several ways to do so. A simple way is to search in the NCBI databases for the entire genome and download as `FASTA` file (we cover the properties of this file format in [Ch 5](../chs-sequence-analysis/introduction-to-sequence-analysis.qmd)).

When inspecting the file we see the following lines at the top

``` bash
>NZ_CP048852.1 Bacillus tequilensis strain EA-CB0015 chromosome, complete genome
ATGGAAAATATATTAGACCTGTGGAATCAAGCCCTTGCTCAAATCGAAAAAAAGTTGAGCAAACCGAGTTTTGAGACTTG
GATGAAATCCACCAAAGCCCACTCACTGCAGGGAGATACACTGACGATCACGGCTCCCAATGAATTTGCCAGAGACTGGC
TGGAGTCCAGATACTTGCATCTGATTGCAGATACTATATATGAATTAACCGGGGAAGAATTGAGCATTAAGTTTGTCATT
CCTCAAAATCAAGATGTTGAGGACTTTATGCCAAAGCCGCAAGTCAAAAAAGCGGTTAAAGAAGATACATCTGATTTTCC
```

The file is about 4 Mb and it is heavy to be opened in any editor. Therefore when looking for a pattern it becomes more useful the CLI.

A first attempt to do is simply by using `grep` for the pattern presented on [Fig. @fig-motif]. So a first problem you will find is to represent multiple characters in one position of the pattern. There is a fantastic tool to so and its called *regular expressions* (regex). a regex is a way to encode groups of characters using single characters. For instance the character `*` (wildcards) represents any character, so it groups all characters and it is used broadly on the CLI. There are many regex dialects however and for `grep` the dot `.` represents any character and when the pipe `|` represents an special operator in the CLI, for grep regex it represents and `OR` operator.

So, the second step is to create our regular expression. Note the there are six characters in the expression that can adopt different characters. So our first regex is `TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT`. In the expression the parenthesis allow groups of characters.

Now lets see if we can search for that pattern using `grep` and the appropriate option for using regex, which in this case is `-E`. Another simply way to use the `grep -E` combination is to use simple `egrep` command plus the `-c` option to count the number of *lines* where the pattern appears.

```{bash}
#| eval: true
egrep -c "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT" data/Bteq-genome.fasta
```

Is this the solution? One might think it is solved. However, there are several issues to be aware. First `egrep -c` is counting the lines, what if in one line there are multiple matches? Then, the approach will showing a value under the actual number of motifs. So a way to solve that is to capture and extract the matches and print them out. A way to do that is to use the option `-o` which actually prints only the matching part of the lines, and then count them.

```{bash}
#| eval: true
egrep -oc "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT" data/Bteq-genome.fasta
```

The outcome is the same tough. So is it solved? Every NCBI genome that is downloaded display a distinct character besides de nucleotide sequence. Every several number of nucleotides there is a new line `\n` that enables the wrapping file into multiple lines. Therefore some motifs could be shopped by the `\n` character so they will never appear with the regex used. A way to circumvent this issue is deleting the `\n` in the entire file. We can easily do that with the translate `tr` command:

```{bash}
#| eval: false
tr -d '\n' < data/Bteq-genome.fasta
```

``` bash
>NZ_CP048852.1 Bacillus tequilensis strain EA-CB0015 chromosome, complete genomeATGGAAAATATATTAGACCTGTGGAATCAAGCCCTTGCTCAAATCGAAAAAAAGTTGAGCAAACCGAGTTTTGAGACTTGGATGAAATCCACCAAAGCCCACTCACTGCAGGGAGATACACTGACGATCACGGCTCCCAATGAATTTGCCAGAGACTGGCTGGAGTCCAGATACTTGCATCTGATTGCAGATACTATATATGAATTAACCGGGGAAGAATTGAGCATTAAGTTTGTCATTCCTCAAAATCAAGATGTTGAGGACTTTATGCCAAAGCCGCAAGTCAAAAAAGCGGTTAAAGAAGATACATCTGATTTTCC...
```

The genome now lies in an entire and unique line along with its title. A way to chain the commands without creating intermediate files is by using the pipe `|` character. At the end we will use `wc -l` to count the occurrence (although `grep` has its own count option `\c` it is inconvenient because it will count the lines and now the lines of the exact matches provided by the `-o` option and as we have just one line, then only will count to 1).

```{bash}
tr -d '\n' < data/Bteq-genome.fasta |
    egrep -o "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT" |
    wc -l
```

Are there yet? Well it turns out that the genome file contains only the 5'-3' strand of the genome. What about the other strands patterns? To search them we need to generate the reverse-complement (RC) of the motif so we are sure that they will appear when looking the 5'-3' strand. The RC regex will be `ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA"` and adding this regex to the search willl be:

```{bash}
tr -d '\n' < data/Bteq-genome.fasta |
    egrep -o "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT|ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA" |
    wc -l
```

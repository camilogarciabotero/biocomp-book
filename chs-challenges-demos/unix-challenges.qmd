---
execute: 
  engine: knitr
  freeze: auto
filters:
  # - code-filename
  - nutshell
  - lightbox
---
# Unix challenges {.unnumbered}

## Motif search {#sec-motifsearch}

The first thing we must do to solve the [Challenge](../chs-command-line/welcome-to-command-line.qmd#anatomy-of-a-command) is download the sequence of interest. In [Ch 1](../chs-command-line/welcome-to-command-line.qmd#anatomy-of-a-command) the genome of *Bacillus tequilensis* EA-CB0015 is proposed. There are several ways to do so. A simple way is to search in the NCBI databases for the entire genome and download as `FASTA` file (we cover the properties of this file format in [Ch 5](../chs-sequence-analysis/introduction-to-sequence-analysis.qmd)).

When inspecting the file we see the following lines at the top

```{.bash}
>NZ_CP048852.1 Bacillus tequilensis strain EA-CB0015 chromosome, complete genome
ATGGAAAATATATTAGACCTGTGGAATCAAGCCCTTGCTCAAATCGAAAAAAAGTTGAGCAAACCGAGTTTTGAGACTTG
GATGAAATCCACCAAAGCCCACTCACTGCAGGGAGATACACTGACGATCACGGCTCCCAATGAATTTGCCAGAGACTGGC
TGGAGTCCAGATACTTGCATCTGATTGCAGATACTATATATGAATTAACCGGGGAAGAATTGAGCATTAAGTTTGTCATT
CCTCAAAATCAAGATGTTGAGGACTTTATGCCAAAGCCGCAAGTCAAAAAAGCGGTTAAAGAAGATACATCTGATTTTCC
```

The file is about 4 Mb and it is heavy to be opened in any editor. Therefore when looking for a pattern it becomes more useful the CLI.

A first attempt to do is simply by using `grep` for the pattern presented on [Fig. @fig-motif]. So a first problem you will find is to represent multiple characters in one position of the pattern. There is a fantastic tool to so and its called *regular expressions* (regex). a regex is a way to encode groups of characters using single characters. For instance the character `*` (wildcards) represents any character, so it groups all characters and it is used broadly on the CLI. There are many regex dialects however and for `grep` the dot `.` represents any character and when the pipe `|` represents an special operator in the CLI, for grep regex it represents and `OR` operator.

So, the second step is to create our regular expression. Note the there are six characters in the expression that can adopt different characters. So our first regex is `TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT`. In the expression the parenthesis allow groups of characters.

Now lets see if we can search for that pattern using `grep` and the appropriate option for using regex, which in this case is `-E`. Another simply way to use the `grep -E` combination is to use simple `egrep` command plus the `-c` option to count the number of *lines* where the pattern appears.

```{bash}
#| eval: true
egrep -c "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT" data/Bteq-genome.fasta
```

Is this the solution? One might think it is solved. However, there are several issues to be aware. First `egrep -c` is counting the lines, what if in one line there are multiple matches? Then, the approach will showing a value under the actual number of motifs. So a way to solve that is to capture and extract the matches and print them out. A way to do that is to use the option `-o` which actually prints only the matching part of the lines, and then count them.

```{bash}
#| eval: true
egrep -oc "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT" data/Bteq-genome.fasta
```

The outcome is the same tough. So is it solved? Every NCBI genome that is downloaded display a distinct character besides de nucleotide sequence. Every several number of nucleotides there is a new line `\n` that enables the wrapping file into multiple lines. Therefore some motifs could be shopped by the `\n` character so they will never appear with the regex used. A way to circumvent this issue is deleting the `\n` in the entire file. We can easily do that with the translate `tr` command:

```{bash}
#| eval: false
tr -d '\n' < data/Bteq-genome.fasta
```

```{.bash}
>NZ_CP048852.1 Bacillus tequilensis strain EA-CB0015 chromosome, complete genomeATGGAAAATATATTAGACCTGTGGAATCAAGCCCTTGCTCAAATCGAAAAAAAGTTGAGCAAACCGAGTTTTGAGACTTGGATGAAATCCACCAAAGCCCACTCACTGCAGGGAGATACACTGACGATCACGGCTCCCAATGAATTTGCCAGAGACTGGCTGGAGTCCAGATACTTGCATCTGATTGCAGATACTATATATGAATTAACCGGGGAAGAATTGAGCATTAAGTTTGTCATTCCTCAAAATCAAGATGTTGAGGACTTTATGCCAAAGCCGCAAGTCAAAAAAGCGGTTAAAGAAGATACATCTGATTTTCC...
```

The genome now lies in an entire and unique line along with its title. A way to chain the commands without creating intermediate files is by using the pipe `|` character. At the end we will use `wc -l` to count the occurrence (although `grep` has its own count option `\c` it is inconvenient because it will count the lines and now the lines of the exact matches provided by the `-o` option and as we have just one line, then only will count to 1).

```{bash}
tr -d '\n' < data/Bteq-genome.fasta |
    egrep -o "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT" |
    wc -l
```

Are there yet? Well it turns out that the genome file contains only the 5'-3' strand of the genome. What about the other strands patterns? To search them we need to generate the reverse-complement (RC) of the motif so we are sure that they will appear when looking the 5'-3' strand. The RC regex will be `ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA"` and adding this regex to the search willl be:

```{#lst-motif-search .bash lst-cap="A bash one-line that search a motif in a single genome file and printed the number of times it occurs"}
tr -d '\n' < data/Bteq-genome.fasta |
    egrep -o "TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT|ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA" |
    wc -l
```

## Motif search in multiple files

```{#lst-recursive-motif-search .bash lst-cap="A bash script that recursively search a motif in genome files and printed for each file the number of times it occurs"}
#! /usr/bin/env bash

motif="TAAA(T|A)(.)(T|A)(G|A)(.)(C|A)GGT|ACC(T|G)(.)(T|C)(T|A)(.)(T|A)TTTA"

for f in $(ls $1); do
  if [ -s ${1}/${f} ]; then
      motifnumber=$(tr -d '\n' < ${1}/${f} | egrep -o $motif | wc -l)
      header=$(head -n 1 ${1}/${f})
      echo -e "There are $motifnumber motifs in $header"
  else
      echo "$f is empty"
  fi
done
```
To execute the command make sure to pass a folder with the decompressed genomes as the first argument.

## Fragments digestion

The first thing we need to do to solve this challenge is to identify the motif of [:*EcoRV*](https://en.wikipedia.org/wiki/EcoRV). As it is a very known enzyme its recognition motif is very clear, so it is then `5'-GAT|ATC-3'` Restriction of these motifs generate blunt ends which are less efficient than sticky ends. So, lets search how many of these motifs appeared the SARS-CoV2 genome sequence. To do that we will use simply `grep` on a linearized form of the genome generated by `tr` (see @sec-motifsearch)

```{bash}
tr -d "\n" < data/Sarscov2-genome.fasta | grep -o "GATATC"
```

Now we want to generate fragments as if the enzyme digest those motifs. A *in silico* way to do this is simply generate new lines where the motif is recognized, using a search/replace strategy. One way to so is with `sed`. It is a tool for stream editing, in other words it will navigate a file searching for patterns and editing for a different one that is required. We need to find the motif and insert a new line so that it generate a file with the restricted fragments that will be in other terms: `sed 's/GATATC/GAT\nATC/g`.

```{bash}
tr -d "\n" < data/Sarscov2-genome.fasta | sed 's/GATATC/GAT\nATC/g'
```

This is a way too long output, however one thing that is clear is that the file header is being combined with the sequence *per se* so we can avoid it from the tail of the file: 

```{bash}
#| eval: false
tail -n +2 data/Sarscov2-genome.fasta > tr -d "\n" | sed 's/GATATC/GAT\nATC/g'
```

This will avoid the deletion of the newline for the header. 

Now we want to see how many fragments there are (separated by the new-line character `\n`). A simple way to do it is to create a environmental variable for the previous process and then we can see `fragments` by simply printing with `echo`.

```{bash}
fragments=$(tail -n +2 data/Sarscov2-genome.fasta | tr -d "\n" | sed 's/GATATC/GAT\nATC/g')

echo $fragments
```

Now we got a simple genome line with some new-line characters appearing where the motif was digested. To count the size of the each fragment we just need to loop over the lines and then count their characters, we can do that with `wc -c`. We can finally end ith the following two lines of code:

```{bash}
fragments=$(tail -n +2 data/Sarscov2-genome.fasta | tr -d "\n" | sed 's/GATATC/GAT\nATC/g')

for line in $fragments; do
    echo $line | wc -c
done
```


A generalization of the previous lines could easily be wrapped around as a bash script by adding the shebang header and changing the hardcoded input  into a argument environmental variable.

```{#lst-ecorv-digestion .bash lst-cap="A bash script that search a motif in a genome file and digest the sequence on the specified restriction motif, then generate the fragments and count their sizes"}
#! /usr/bin/env bash

fragments=$(tail -n +2 $1 | tr -d "\n" | sed 's/GATATC/GAT\nATC/g')

for line in $fragments; do
    echo $line | wc -c
done
```
